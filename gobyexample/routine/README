Two styles of concurrency exist:
    deterministic (well-defined ordering) and non-deterministic (locking/mutual exclusion but order undefined).
    Go’s goroutines and channels promote deterministic concurrency (e.g. channels with one sender, one receiver), which is easier to reason about.
    We will compare both approaches in a commonly occurring algorithm (the Worker-problem)
    deterministic concurrent 编程： the outputs of the program depend solely on the inputs of the program.

Goroutines are lightweight, much lighter than a thread.
    They have a very small footprint (use little memory and resources): they are created with a 4K memory stack-space on the heap. 在堆上模拟出一个虚拟的栈

a goroutine is mapped onto (multiplexed, executed by) one or more threads, according to their availability;
this is accomplished by the goroutine-scheduler in the Go runtime.

More processors however don’t mean necessarily a linear improvement in performance, mainly because more communication is needed: the message-passing overhead increases.

The logic of your code must be independent of the order in which goroutines are invoked.

all types can be used in a channel. A channel is in fact a typed message queue

So channels are first class objects: they can be stored in variables, passed as arguments to functions, returned from functions and sent themselves over channels. Moreover they are typed, allowing the type system to catch programming errors like trying to send a pointer over a channel of integers.

Although not necessary, for readability the channel name usually starts with ch or contains ‘chan’.

Don’t use print statements to indicate the order of sending to and receiving from a channel: this could be out of order with what actually happens due to the time lag between the print statement and the actual channel sending and receiving.

But design your algorithm in the first place with unbuffered channels, and only introduce buffering when the former is problematic.

空间换时间
Since the number of items in the container is generally known, it makes sense to use a channel with enough capacity to hold all the items. This way, the iterator will never block (though the consumer goroutine still might). However, this effectively doubles the amount of memory required to iterate over any given container, so channel capacity should be limited to some maximum number. Timing or benchmarking your code will help you find the buffer capacity for minimal memory usage and optimal performance.

Thus not only performance is a major advantage, but the clearer and more elegant code is perhaps an even bigger advantage. It is certainly a Go idiomatic way of working:
IDIOM: Use an in- and out-channel instead of locking

For any problem which can be modeled as such a Master-Worker paradigm, an analogous solution with Workers as goroutines communicating through channels and the Master as coordinator would be a perfect fit. If the system distributes over several machines, a number of machines could execute the Worker goroutines, and the Master and Workers could communicate amongst themselves through netchan or rpc (see chapter 15).

tail recursion
