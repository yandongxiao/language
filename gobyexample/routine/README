Two styles of concurrency exist:
    deterministic (well-defined ordering) and non-deterministic (locking/mutual exclusion but order undefined).
    Go’s goroutines and channels promote deterministic concurrency (e.g. channels with one sender, one receiver), which is easier to reason about.
    We will compare both approaches in a commonly occurring algorithm (the Worker-problem)
    deterministic concurrent 编程： the outputs of the program depend solely on the inputs of the program.

Goroutines are lightweight, much lighter than a thread.
    They have a very small footprint (use little memory and resources): they are created with a 4K memory stack-space on the heap. 在堆上模拟出一个虚拟的栈

a goroutine is mapped onto (multiplexed, executed by) one or more threads, according to their availability;
this is accomplished by the goroutine-scheduler in the Go runtime.

More processors however don’t mean necessarily a linear improvement in performance, mainly because more communication is needed: the message-passing overhead increases.

The logic of your code must be independent of the order in which goroutines are invoked.

all types can be used in a channel. A channel is in fact a typed message queue

So channels are first class objects: they can be stored in variables, passed as arguments to functions, returned from functions and sent themselves over channels. Moreover they are typed, allowing the type system to catch programming errors like trying to send a pointer over a channel of integers.

Although not necessary, for readability the channel name usually starts with ch or contains ‘chan’.

Don’t use print statements to indicate the order of sending to and receiving from a channel: this could be out of order with what actually happens due to the time lag between the print statement and the actual channel sending and receiving.

But design your algorithm in the first place with unbuffered channels, and only introduce buffering when the former is problematic.
