#! /usr/bin/python

def apply_async(func, args, *, callback):
    # Compute the result
    result = func(*args)

    # Invoke the callback with the result
    callback(result)

# A simple function for testing
def add(x, y):
    return x + y

# method1
def print_result(result):
    print("Got: {}".format(result))

print("# --- Simple Example")
apply_async(add, (2, 3), callback=print_result)
apply_async(add, ('hello', 'world'), callback=print_result)

#method 2
class Dxyan :
    def __init__(self):
        self.cnt = 0
    def print_result(self, result):
        self.cnt += 1
        print("[{}] Got: {}".format(self.cnt, result))

print("# --- Using a bound-method")
ins = Dxyan()
apply_async(add, (2, 3), callback=ins.print_result)
apply_async(add, ('hello', 'world'), callback=ins.print_result)

#method3
def func():
    cnt = 0;
    def print_result3(result):
        nonlocal cnt;
        cnt += 1
        print("[{}] Got: {}".format(cnt, result))
    return print_result3;

print("# --- Using a closure")
callback = func()
apply_async(add, (2, 3), callback=callback)
apply_async(add, ('hello', 'world'), callback=callback)


#method 4
def func4():
    cnt = 0
    while True:
        cnt += 1
        result = yield      #result is the value passed to me.
        print("[{}] Got: {}".format(cnt, result))
handle = func4()
next(handle)    #start the gen

print('# --- Using a coroutine')
apply_async(add, (2, 3), callback=handle.send)
apply_async(add, ('hello', 'world'), callback=handle.send)



#method 5
from functools import partial
class ttt:
    def __init__(self):
        self.cnt = 0
def func5(value, self):
    self.cnt += 1
    print("[{}] Got: {}".format(self.cnt, value))

self = ttt()
print("# --- Using partial")
apply_async(add, (2, 3), callback = partial(func5,self=self))
apply_async(add, ('hello', 'world'), callback= partial(func5,self=self))
