1、如何定义一个类？

    class Test:
    ...     pass
    ... 
    >>> test=Test()
    >>> test
    <__main__.Test instance at 0x7fc924045638>
    >>> 


2、类实例式如何初始化的？
    >>> class Test:
    ...     def __init__(self, num1, num2):
    ...         self.num1 = num1
    ...         self.num2 = num2
    ... 
    >>> 
    >>> 
    >>> test=Test(1,2)
    >>> test.num1
    1
    >>> test.num2
    2
解释以下问题：
1、__init__函数在什么时候被调用？每次实例化一个对象时，该类方法被调用. 类方法的第一个参数代表类实例本身，所以也可以认为__self__是类实例化一个对象后第一个调用的函数。
2、__init__函数为什么前后有两个下划线？这是系统提供的具有特殊意义的类方法，同理，如果类定义了__getitem__方法，那么就可以采用test[]的形式来调用该特殊类方法。所以，自己定义的类一般不要采用这种形式，免得和系统定义的产生冲突。引申出来的另一个问题：特殊类方法有哪些，哪些又是常见的？ aaaa.


3、如何继承一个已有的类？
    >>> class childTest(Test):
    ...     def __init__(self, name, age, num1, num2):
    ...         Test.__init__(self, num1, num2)
    ...         self.name = name
    ...         self.age = age
    ... 
    >>> cd = childTest("xiaoming", 15, 1, 2)
    >>> 
    >>> cd.name
    'xiaoming'
    >>> cd.age
    15
    >>> cd.num1
    1
    >>> cd.num2
    2
解释以下问题：
1、继承了父类的什么？父类有数据属性num1和num2，以及类方法__init__,以上内容均被子类继承。引申出来的另一个问题：如何定义私有属性和方法？ aaaa.
2、childTest与Test中的__init__的关系？Python不支持重载，还记得C/C++中重载的概念吗？由于返回值、参数类型或参数个数的不同，使得两个函数名相同的函数或类实际上在C
/C++内部被表示成了不同的两个函数。重申一遍，Python不支持重载。所以父类的__init__方法显然被覆盖。
3、语句Test.__init__(self, num1, num2)代表什么含义？ python不会自动调用继承的类方法（C/C++可是有偷偷调用父类构造函数的行为），一般情况下，子类要覆盖父类的方法，必须在新方法中调用父类的方法。而且最好是一开始就调用。


4、Python中的静态方法和属性？
    >>> class Test2:
    ...     var1=10
    ...     @staticmethod
    ...     def mymethod():
    ...         print "mymethod : %d" % (Test2.var1,)
    ... 
    >>> Test2.var1
    10
    >>> Test2.mymethod()
    mymethod : 10
    >>> Test2().mymethod()
    mymethod : 10
    >>> Test2.var1 = 20
    >>> Test2.var1
    20
    >>> Test2().var1=30
    >>> Test2.var1
    20
    Test2().xxxx = 10
解释以下问题：
1、@staticmethod. 如果没加这一行，那么你定义的这个函数很难被外界调用. 还有另外一种方法式在类中定义cmd=classmethod(mymethod),以后用Test2.cmd的方法调用类方法。推荐第一种
2、Test2().var1=30并没有修改Test2.var1的值？ 这是因为你为实例定义了一个新的成员变量，不要惊讶。在类实例的生命周期内你随时可以增加和删除自己的成员变量。就像最后Test2().xxxx=10一样。证明的另外一件事情是类外面引用类属性的方法是Test2.var1.  引申的一个问题，在实例方法中可以利用self.var1访问它吗？可以，如下。
        >>> class Test3():
        ...     var1=10
        ...     @staticmethod
        ...     def addStatic():
        ...         Test3.var1 += 10
        ...     def __init__(self):
        ...         self.var1 += 10


5、如何确保自己定义的属性和方法是私有的？
    >>> class Test:
    ...         __var1 = 1
    ...         @staticmethod
    ...         def __sm():
    ...                 pass
    ...         def __init__(self):
    ...                 self.__var2 = 2
    ...         def __method(self):
    ...                 pass
    ... 
    >>> test=Test()
    >>> dir(test)
    ['_Test__method', '_Test__sm', '_Test__var1', '_Test__var2', '__doc__', '__init__', '__module__']

    >>> class childTest(Test):
    ...         __cvar1 = 20
    ...         cvar2 = 20
    ...         def __mthod(self):
    ...                 Test.__method(self)
    ...                 Test.__var1 = 20
    ... 
    >>> 
    >>> dir(childTest)
    ['_Test__method', '_Test__sm', '_Test__var1', '__doc__', '__init__', '__module__', '_childTest__cvar1', '_childTest__mthod', 'cvar2']
    >>> childTest().__method()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: childTest instance has no attribute '__method'
    >>> childTest()._childTest__mthod()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "<stdin>", line 5, in __mthod
    AttributeError: class Test has no attribute '_childTest__method'

解释以下问题：
1、__cvar1和cvar2变量的区别？ 在dir(childTest)的输出中我们发现了_childTest__cvar1和cvar2变量，那么__cvar1变量去哪里了。Python将以双下划线开头__cvar1变量转变为了_childTTest__cvar1变量了。（不要以为C/C++没有，我们定义的变量在编译器阶段早已经被它们改的面目全非了）. 这也间接解释了第二个问题。
2、解释childTest().__method()的错误。注意，在类的外部调用__method方法时，python并没有自动将它转变为_childTest__method,所以会报这个错误。（这里有个小错误就是子类中的mthod方法，应该是method方法，即便式__method,python也会将它转换成_childTest__method,不会覆盖_Test__method方法）。 
2、解释childTest()._childTest__method()报的错误？ 首先调用_childTest__method方法成功了，错误发生在Test.__method(self)，此时__method照样被解释成了_childTest__method，在Test类中自然不会有这个方法。
3、通过以上分析，Python只是玩了一下偷换名称的把戏，那么在子类当中调用父类的方法就有以下方法。
        >>> class childTest(Test):
        ...         __cvar1 = 20
        ...         cvar2 = 20
        ...         def __mthod(self):
        ...                 Test._Test__method(self)
        ...                 Test._Test__var1 = 20
        ... 
        >>> dir(childTest)
        ['_Test__method', '_Test__sm', '_Test__var1', '__doc__', '__init__', '__module__', '_childTest__cvar1', '_childTest__mthod', 'cvar2']
        >>> ct = childTest()
        >>> ct._childTest__mthod()
        >>>


6、类存在析构函数吗？
    >>> class Test2:
    ...     def __del__(self):
    ...         print "__del__"
    ... 
    >>> a=Test2()
    >>> b=a
    >>> del b
    >>> del a
    __del__
__del__与__init__方法都属于Python下特殊的类方法，其中Test2的实例对象只有自己在被销毁的时候，__del__才会被调用
    
